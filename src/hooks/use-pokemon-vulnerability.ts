import { Pokemon } from "models";

type PokemonType =
    | "Bug" | "Ice" | "Dark" 
    | "Fire" | "Rock" | "Ghost" 
    | "Grass" | "Fairy" | "Steel" 
    | "Water" | "Dragon" | "Flying" 
    | "Ground" | "Normal" | "Poison" 
    | "Psychic" | "Electric" | "Fighting";

// Type Safety Readonly
type TypeVulnerabilities = Readonly<{  
    [key in PokemonType]: ReadonlyArray<PokemonType>; 
}>;

// Data Consistency: Use as const for TypeVulnerabilities
const typeVulnerabilities: TypeVulnerabilities = {
    Bug:        ["Fire", "Flying", "Rock"] as const,
    Ice:        ["Fire", "Fighting", "Rock", "Steel"] as const,
    Dark:       ["Fighting", "Bug", "Fairy"] as const,
    Fire:       ["Water", "Rock", "Ground"] as const,
    Rock:       ["Water", "Grass", "Fighting", "Ground", "Steel"] as const,
    Ghost:      ["Ghost", "Dark"] as const,
    Grass:      ["Fire", "Ice", "Poison", "Flying", "Bug"] as const,
    Fairy:      ["Poison", "Steel"] as const,
    Steel:      ["Fire", "Fighting", "Ground"] as const,
    Water:      ["Electric", "Grass"] as const,
    Dragon:     ["Ice", "Dragon", "Fairy"] as const,
    Flying:     ["Electric", "Ice", "Rock"] as const,
    Ground:     ["Water", "Grass", "Ice"] as const,
    Normal:     ["Fighting"] as const,
    Poison:     ["Ground", "Psychic"] as const,
    Psychic:    ["Bug", "Ghost", "Dark"] as const,
    Electric:   ["Ground"] as const,    
    Fighting:   ["Flying", "Psychic", "Fairy"] as const,
};

function toInitialCase(typeName: string): PokemonType {
    return typeName.charAt(0).toUpperCase() + typeName.slice(1).toLowerCase() as PokemonType;
}

// obtainVulnerability function using Set for efficient unique element handling
function obtainVulnerability(pokemonTypes: PokemonType[]): PokemonType[] {
    return Array.from(new Set(pokemonTypes.flatMap(type => typeVulnerabilities[type]))); 
}

export function getVulnerabilitiesFromApi(apiTypes: string[]): PokemonType[] {
    return obtainVulnerability(apiTypes.map(toInitialCase));
}

type VulnerabilitiesTypes = {
    vulnerabilities: string[];
    types: string[];
}

export function usePokemonVulnerabilitiesTypes(pokemon: Pokemon | undefined): VulnerabilitiesTypes {

  // Early return if pokemon is undefined
  if (!pokemon) {
    return { vulnerabilities: [], types: [] }; 
  }

  // Extract types efficiently using a single map operation
  const types = pokemon.types.map(type => type.type.name);

  // Calculate vunerabilities
  const vulnerabilities = getVulnerabilitiesFromApi(types);

  return { vulnerabilities, types };
}
